rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // =====================================================================
    // SECTION 1: CORE HELPER FUNCTIONS (The Building Blocks)
    // =====================================================================

    // ---[ Block 1.1: Authentication & Identity Helpers ]---

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwnerOfDocument(userId) {
      return request.auth.uid == userId;
    }

    // ---[ Block 1.2: Group Membership & Role Helpers ]---

    function isMemberOf(groupId) {
      let groupData = get(/databases/$(database)/documents/groups/$(groupId)).data;
      return request.auth.uid in groupData.participantUids;
    }

    // ---[ Block 1.3: Data Validation Helpers ]---

    /**
     * The master validation function for creating a new group.
     * It relies on direct property access, which has been proven to be reliable.
     */
    function isValidNewGroup() {
      let group = request.resource.data;
      let creatorUid = request.auth.uid;

      return group.ownerUid == creatorUid
          && group.participants[0].uid == creatorUid
          && group.participants[0].role == 'admin';
    }
    
    // ---[ Block 1.4: Data Validation Helpers for 'update' ]---

    /**
     * Returns true if the requesting user IS an admin of the group.
     * This rule is for "additive" or simple changes that cannot remove an admin.
     * It uses the `resource.data` to check the user's role before the change.
     */
    function requesterIsAdmin() {
      return request.auth.uid in resource.data.participantUids &&
             resource.data.participants.exists(p, p.uid == request.auth.uid && p.role == 'admin');
    }

    /**
     * The "Last Admin Rule". Returns true if the proposed update does not
     * result in a group having zero administrators.
     */
    function newAdminCountIsAtLeastOne() {
      return size(request.resource.data.participants.filter(p, p.role == 'admin')) >= 1;
    }

    /**
     * Logic for when a new user is joining a group via an invite link.
     */
    function isUserJoiningGroup() {
      let wasMember = request.auth.uid in resource.data.participantUids;
      let isNowMember = request.auth.uid in request.resource.data.participantUids;
      return !wasMember && isNowMember;
    }
    
    // =====================================================================
    // SECTION 2: COLLECTION-LEVEL RULES (The Assembly)
    // =====================================================================

    match /users/{userId} {
      allow read, write: if isAuthenticated() && isOwnerOfDocument(userId);
    }

    match /groups/{groupId} {
      allow read: if isAuthenticated() && request.auth.uid in resource.data.participantUids;
      
      allow create: if isAuthenticated() && isValidNewGroup();
      
      allow update: if (
        // Path 1: Additive changes (like adding a new participant) only
        // require the requester to be an admin.
        requesterIsAdmin() ||

        // Path 2: A new user is joining via an invite.
        isUserJoiningGroup() ||

        // Path 3: Any "subtractive" change (leaving, being removed/demoted)
        // is valid as long as the "Last Admin Rule" is satisfied.
        // We trust the client to only allow admins or self-removal to trigger these actions.
        newAdminCountIsAtLeastOne()
      );

      allow delete: if requesterIsAdmin();
      
      match /turnLog/{logId} {
        allow read: if isMemberOf(groupId);
        
        allow create: if isMemberOf(groupId);
        
        allow delete: if false;

        allow update: if requesterIsAdmin()
                      && request.resource.data.isUndone == true
                      && resource.data.isUndone == false;
      }
    }
  }
}