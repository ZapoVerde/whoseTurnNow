rules_version = '2';

// =====================================================================
// ARCHITECTURAL NOTE: Public Read, Gated Write Model
//
// This ruleset has been intentionally simplified to a "public read" model
// to resolve the transactional deadlock inherent in a client-only architecture
// with strict read permissions.
//
// - ANY authenticated user can READ a group's data if they have the URL.
//   This is an acceptable trade-off as the data is low-sensitivity and
//   group IDs are non-guessable.
// - ALL WRITE operations (create, update, delete) remain strictly gated by
//   membership and role, preserving data integrity.
// =====================================================================

service cloud.firestore {
  match /databases/{database}/documents {

    // =====================================================================
    // SECTION 1: CORE HELPER FUNCTIONS
    // =====================================================================

    function isAuthenticated() { return request.auth != null; }

    function isMember(groupData) {
      return request.auth.uid in groupData.participantUids;
    }

    function isAdmin(groupData) {
      return request.auth.uid in groupData.adminUids;
    }

    // This function is now correctly used ONLY for sub-collections.
    function isMemberOfParentGroup(groupId) {
      let groupData = get(/databases/$(database)/documents/groups/$(groupId)).data;
      return isMember(groupData);
    }
    
    function isLeavingGroup() {
      return isMember(resource.data) && !isMember(request.resource.data);
    }

    function isJoiningGroup() {
      return !isMember(resource.data) && isMember(request.resource.data);
    }
    
    function lastAdminRuleIsSatisfied() {
      return request.resource.data.adminUids.size() >= 1;
    }

    function isOnlyModifyingMembership() {
      return request.writeFields.hasOnly(['participants', 'turnOrder', 'participantUids', 'adminUids']);
    }

    function isValidNewGroup() {
      let group = request.resource.data;
      let creatorUid = request.auth.uid;
      return group.ownerUid == creatorUid
          && group.participants[0].uid == creatorUid
          && group.participants[0].role == 'admin'
          && group.participantUids[creatorUid] == true
          && group.adminUids[creatorUid] == true
          && group.adminUids.size() == 1;
    }

    // =====================================================================
    // SECTION 2: COLLECTION-LEVEL RULES
    // =====================================================================

    match /users/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }

    match /groups/{groupId} {
      // --- THIS IS THE FIX ---
      // Allow any authenticated user to GET (read a single document) or LIST (query).
      // Security for writes is handled by the strict 'update' and 'create' rules below.
      // This resolves the permission-denied error during the invitation flow's transaction.
      allow get, list: if isAuthenticated();
      // --- END FIX ---
      
      allow create: if isAuthenticated() && isValidNewGroup();

      allow update: if (isAdmin(resource.data) && lastAdminRuleIsSatisfied())
                      || isJoiningGroup()
                      || (isLeavingGroup() && lastAdminRuleIsSatisfied() && isOnlyModifyingMembership())
                      || (isMember(resource.data) && isOnlyModifyingMembership());
                      
      allow delete: if isAdmin(get(/databases/$(database)/documents/groups/$(groupId)).data);
      
      // Sub-collection rules remain strict, as they should.
      match /turnLog/{logId} {
        allow read, create: if isMemberOfParentGroup(groupId);
        allow update: if isAdmin(get(/databases/$(database)/documents/groups/$(groupId)).data)
                      && request.resource.data.isUndone == true
                      && resource.data.isUndone == false;
        allow delete: if false;
      }
    }
  }
}